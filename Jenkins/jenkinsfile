pipeline {
    agent any

    parameters {
        choice(name: 'ENV', choices: ['staging'], description: 'Choose non-dev environment')
    }

    environment {
        AWS_REGION = credentials('aws-region')
        AWS_ACCESS_KEY_ID = credentials('jenkins-iam-access')
        AWS_SECRET_ACCESS_KEY = credentials('jenkins-iam-secret')

        DB_PASSWORD = credentials('rds-db-password')
        DB_USERNAME = credentials('rds-db-username')
        ECR_REPO = 'your-account-id.dkr.ecr.${AWS_REGION}.amazonaws.com/myapp'
    }

    tools {
        terraform 'terraform-1.6'
    }

    options {
        timestamps()
        ansiColor('xterm')
    }

    stages {

        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Terraform Init & Plan') {
            steps {
                dir("terraform/environments/${params.ENV}") {
                    sh 'terraform init -backend-config=../../backend.tf'
                    sh 'terraform plan -out=tfplan'
                }
            }
        }

        stage('Terraform Apply') {
            steps {
                dir("terraform/environments/${params.ENV}") {
                    sh 'terraform apply -auto-approve tfplan'
                }
            }
        }

        stage('Fetch Monitoring EC2 IP') {
            steps {
                script {
                    env.ANSIBLE_HOST = sh(
                        script: "terraform -chdir=terraform/environments/${params.ENV} output -raw monitoring_ec2_ip",
                        returnStdout: true
                    ).trim()
                }
            }
        }

        stage('Configure Monitoring with Ansible') {
            steps {
                withCredentials([sshUserPrivateKey(credentialsId: 'ansible-ssh-key', keyFileVariable: 'SSH_KEY')]) {
                    sh '''
                        cd ansible/playbooks
                        export ANSIBLE_HOST_KEY_CHECKING=False
                        ansible-playbook -i "$ANSIBLE_HOST," configure-ec2-prom-grafana.yml \
                          --private-key $SSH_KEY -u ec2-user
                    '''
                }
            }
        }

        stage('Fetch Docker Image Tag from Dev') {
            steps {
                dir('app/deployment/k8s-manifests') {
                    script {
                        def tag = sh(script: "git show origin/dev:app/deployment/k8s-manifests/deployment.yaml | grep 'image:' | awk -F ':' '{print \$3}'", returnStdout: true).trim()
                        env.IMAGE_TAG = tag
                        sh "sed -i 's|image:.*|image: $ECR_REPO:$IMAGE_TAG|' deployment.yaml"

                        sh '''
                            git config user.name "jenkins-bot"
                            git config user.email "jenkins@ci.local"
                            git add deployment.yaml
                            git commit -m "Promote image $IMAGE_TAG to ${params.ENV}"
                            git push origin HEAD:${params.ENV}
                        '''
                    }
                }
            }
        }

        stage('ArgoCD Sync') {
            steps {
                sh "argocd app sync myapp-${params.ENV}"
            }
        }
    }

    post {
        always {
            cleanWs()
        }
        failure {
            mail to: 'devops-team@example.com',
                 subject: "Jenkins Build Failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                 body: "Build failed in ${env.BUILD_URL}"
        }
    }
}
